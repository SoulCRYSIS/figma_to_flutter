---
description: 
globs: 
alwaysApply: false
---
# Flutter Component Creation Guide

When creating **any** Flutter UI component, follow these comprehensive guidelines to ensure consistency, maintainability, and design system compliance:

## üé® Design System Integration

1. **Prefer Design Tokens (fallback to plain values if necessary)**
   ‚Ä¢ Use `Figma` helpers when a matching token exists:
     - Colors: `Figma.colorModes.colorsForegroundFgSuccessPrimary`
     - Typography: `Figma.typography.textSmMedium`
     - Spacing: `Figma.spacing.spacingSm`
     - Border radius: `Figma.radius.radiusSm`
   ‚Ä¢ Avoid hard-coded values when an equivalent design token is available; if no suitable token exists or the generated MCP code uses explicit values, plain values are acceptable.

2. **Icon Management**
   ‚Ä¢ First check [svg_icons.dart](mdc:lib/icons/svg_icons.dart) and [png_icons.dart](mdc:lib/icons/png_icons.dart)
   ‚Ä¢ Use `SvgIcon(SvgIcons.iconName)` for SVG icons
   ‚Ä¢ Use `Image.asset(PngIcons.iconName)` for PNG icons
   ‚Ä¢ Only add new assets when existing ones don't fit the use case

## üèóÔ∏è Architecture & Structure

3. **Component Hierarchy**
   ‚Ä¢ **StatelessWidget** by default - only use StatefulWidget when managing internal state
   ‚Ä¢ Create constructor with named parameters and required fields marked appropriately
   ‚Ä¢ Use `const` constructor when possible for performance

4. **Naming Conventions**
   ‚Ä¢ Component names: `PascalCase` ending with descriptive suffix (e.g., `PrimaryButton`, `ProductCard`, `NavigationDrawer`)
   ‚Ä¢ File names: `snake_case` matching component name (e.g., `primary_button.dart`)
   ‚Ä¢ Parameters: `camelCase` with clear, descriptive names

5. **Code Organization**
   ```dart
   class ComponentName extends StatelessWidget {
     // Constructor with named parameters
     const ComponentName({
       super.key,
       required this.title,
       this.onPressed,
       this.isEnabled = true,
     });

     // Properties
     final String title;
     final VoidCallback? onPressed;
     final bool isEnabled;

     @override
     Widget build(BuildContext context) {
       // Implementation
     }

     // Private helper methods (if needed)
     Widget _buildSubComponent() { }
   }
   ```

## üìù Documentation & Context

7. **Required Documentation**
   ‚Ä¢ **Figma Reference**: Always include the Figma frame URL or node ID
   ‚Ä¢ **Purpose**: Brief description of component's function and usage
   ‚Ä¢ **Example Usage**: Code snippet showing typical implementation
   ‚Ä¢ **Parameters**: Document all public parameters and their expected values

   ```dart
   /// A primary action button following the design system guidelines.
   /// 
   /// Figma Reference: [Button Component](mdc:figma:/node-id)
   /// 
   /// Used for main call-to-action elements throughout the app.
   /// 
   /// Example:
   /// ```dart
   /// PrimaryButton(
   ///   title: 'Continue',
   ///   onPressed: () => _handleContinue(),
   /// )
   /// ```
   class PrimaryButton extends StatelessWidget {
   ```

## üîç Quality Assurance

8. **Before Implementation**
   ‚Ä¢ **ASK** if component variants/states are unclear (hover, pressed, disabled, loading)
   ‚Ä¢ **VERIFY** responsive behavior requirements
   ‚Ä¢ **CONFIRM** interaction patterns and animations
   ‚Ä¢ **CHECK** if component needs theming support

9. **Testing Considerations**
   ‚Ä¢ Components should be testable in isolation
   ‚Ä¢ Avoid tight coupling to specific business logic
   ‚Ä¢ Consider edge cases (empty states, long text, different screen sizes)

## ‚ùå Common Pitfalls to Avoid

- Unnecessarily hard-coding colors, sizes, or spacing values when tokens exist
- Creating overly complex components that do too many things
- Ignoring responsive design principles
- Poor naming that doesn't describe the component's purpose
- Forgetting to handle loading and error states where applicable

## üì± Performance & Best Practices

10. **Optimization**
    ‚Ä¢ Use `const` constructors and widgets where possible
    ‚Ä¢ Avoid unnecessary rebuilds with proper state management
    ‚Ä¢ Consider widget size and complexity for performance
    ‚Ä¢ Use `RepaintBoundary` for complex custom painted components

Integrate these rules with the rest of the design system guidelines in this file to ensure pixel-perfect, maintainable components.

### üîñ Quick Token Reference

Design tokens are auto-generated under [lib/design_tokens](mdc:lib/design_tokens).  The most useful entry points are:

‚Ä¢ **Colors**  
  ‚Äì Semantic: `Figma.colorModes.<tokenName>` (e.g. `Figma.colorModes.colorsForegroundFgSuccessPrimary`)  
  ‚Äì Primitive: `Primitives.<colorName>` (e.g. `Primitives.colorsSuccess600`)

‚Ä¢ **Spacing**  
  `Figma.spacing.<token>` ‚Üí `spacingNone`, `spacingSm`, `spacingMd`, `spacingLg`, `spacingXl`, `spacing2xl`, ‚Ä¶

‚Ä¢ **Radius**  
  `Figma.radius.<token>` ‚Üí `radiusNone`, `radiusSm`, `radiusMd`, `radiusLg`, `radiusFull`, ‚Ä¶

‚Ä¢ **Typography / Text Styles**  
  ‚Äì Numeric tokens: `Figma.typography.<fontSize|lineHeight|fontWeight|fontFamily>‚Ä¶`  
  ‚Äì Ready-made text styles: `Styles.<styleName>` (e.g. `Styles.displayLgRegular`, `Styles.textSmMedium`)

Token getters are `const` and require no context, so you can import them directly without scanning files.
